package com.learning.datatype;

/**
 * @author fanyuwen
 */
public class FFloat {
    //float 32位 最高位符号位
    //CPU表示浮点数由三部分组成,符号位(sign),指数部分(exponent)和有效部分(fraction, mantissa)
    //总共占32位, 符号位 1 位, 指数部分 8 位, 有效部分 23 位
    //对于实数 转化为二进制分为两部分, 第一部分整数, 第二部分小数部分。整数部分计算很简单(二进制)
    //小数部分计算: 将小数乘2, 取整数部分作为二进制的值, 然后再将小数乘2, 再取整数部分, 以此往复循环
    //0.6的转换            整数部分      小数部分
    //  0.6 * 2 = 1.2       1           0.2
    //  0.2 * 2 = 0.4       0           0.4
    //  0.4 * 2 = 0.8       0           0.8
    //  0.8 * 2 = 1.6       1           0.6
    //  0.6 * 2 = 1.2       1           0.2
    //  ......
    //  所以0.6转换为二进制为0.10011001......, 6.6转换为二进制为110.10011001......
    //规约化 通过将小数转为规约形式,类似科学计数法,就是保证小数点前面有一个有效数字。在二进制里面,就是保证整数位是一个1。
    //      110.10011001......规约化为: 1.1010011001*2^2
    //指数偏移值 = 固定值 + 规约化的指数值 固定值=2^(e-1)-1,其中e为存储指数部分的比特位数,前面提到的float为8位。所以float中固定值为127
    //6.6的二进制值规约化以后为1.1010011001*2^2,指数是2,所以偏移值就是127+2=129,转换为二进制就是10000001。
    //6.6为正数,符号位为0,指数部分为偏移值的二进制10000001,有效部分为规约形式的小数部分,取小数的前23位即10100110011001100110011,最后拼接到一起
    //即01000000110100110011001100110011
    //这里小数部分是循环的,但是仍然只能取前23位。double造成精度损失的原因也是如此
    //使用Decimal存在的缺点:
    //1.占用存储空间   =>    浮点类型在存储同样范围的值时,通常比decimal使用更少的空间
    //2.使用decimal计算效率不高   =>    因为使用decimal时间和空间开销较大,选用int作为数据库存储格式比较合适,可以同时避免浮点存储计算的不精确和decimal
    //  的缺点。对于存储数值较大或者保留小数较多的数字,数据库存储结构可以选择bigint
    private float value;
}
